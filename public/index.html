<!-- START OF FILE index.html -->

<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <title>AVALON: Zrozen√≠ Imp√©ria</title>
    <link rel="stylesheet" href="styl.css">
</head>
<body>
    <!-- Sekce LOBBY -->
    <div id="lobby-section">
        <div class="lobby-container" id="name-selection">
            <h1>AVALON</h1>
            <h2>Zrozen√≠ Imp√©ria</h2>
            <input type="text" id="playerNameInput" placeholder="Jm√©no tv√©ho rodu...">
            <button id="findGameBtn">Vstoupit do v√°lky</button>
        </div>
        <div class="lobby-container" id="waiting-room" style="display: none;">
            <h3>Formuje se boji≈°tƒõ...</h3>
            <h4>P≈ô√≠tomn√≠ velitel√©:</h4>
            <ul id="playerList"></ul>
            <p id="waiting-message">ƒåek√°n√≠ na dal≈°√≠ hr√°ƒçe (2 pot≈ôeba)...</p>
        </div>
    </div>

    <!-- Sekce HRA -->
    <div id="game-section" style="display: none;">
        <div class="top-bar">
            <div class="resource-panel">
                <div class="resource" title="Zlato">üí∞ <span id="gold-display">0</span></div>
                <div class="resource" title="J√≠dlo">üçñ <span id="food-display">0</span></div>
                <div class="resource" title="D≈ôevo">üå≤ <span id="wood-display">0</span></div>
                <div class="resource" title="K√°men">‚õèÔ∏è <span id="stone-display">0</span></div>
                <div class="resource" title="Vƒõda">üìö <span id="science-display">0</span></div>
            </div>
             <div class="resource-panel">
                <div class="resource" title="Populace / Limit">üßë‚Äçü§ù‚Äçüßë <span id="pop-display">0/0</span></div>
             </div>
        </div>

        <div id="game-container">
            <div id="game-viewport">
                <canvas id="board-canvas"></canvas>
                <canvas id="entity-canvas"></canvas>
                 <div id="build-ghost"></div>
            </div>
            <div class="right-panel">
                 <div class="selection-panel">
                    <h3 id="selection-name">Nic nevybr√°no</h3>
                    <div id="selection-details"></div>
                    <div id="selection-actions"></div>
                </div>

                <div class="minimap-panel">
                    <h4>Mapa Vlivu</h4>
                    <canvas id="minimap"></canvas>
                </div>

                <div class="global-actions-panel">
                     <h4>Technologie</h4>
                     <div id="tech-tree">
                        <button class="action-button tech-button" data-tech="vylepsene_zemedelstvi" title="Vylep≈°en√© zemƒõdƒõlstv√≠ (50 Vƒõda)">Farma+ (50)</button>
                        <button class="action-button tech-button" data-tech="kovarstvi" title="Kov√°≈ôstv√≠ (100 Vƒõda)">Meƒç+ (100)</button>
                        <button class="action-button tech-button" data-tech="opevneni" title="Opevnƒõn√≠ (75 Vƒõda)">Hradby+ (75)</button>
                     </div>
                </div>
            </div>
        </div>
        <div id="game-tooltip"></div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();

        // --- STAV A KONSTANTY KLIENTA ---
        let gameState = null;
        let myId = null;
        let animationFrameId = null;
        let camera = { x: 0, y: 0, scale: 0.5 };
        const CELL_SIZE = 12; // Men≈°√≠ bu≈àky pro detailnƒõj≈°√≠ pohled
        let selectedUnits = new Set();
        let selectedBuilding = null;
        let placingBuildingType = null;

        // --- KANVAS A KONTEXTY ---
        const boardCanvas = document.getElementById('board-canvas');
        const boardCtx = boardCanvas.getContext('2d', { alpha: false });
        const entityCanvas = document.getElementById('entity-canvas');
        const entityCtx = entityCanvas.getContext('2d');
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');
        
        // --- V√ùBƒöR ELEMENT≈Æ ---
        const lobbySection = document.getElementById('lobby-section');
        const gameSection = document.getElementById('game-section');
        const findGameBtn = document.getElementById('findGameBtn');
        const playerNameInput = document.getElementById('playerNameInput');
        const buildGhost = document.getElementById('build-ghost');
        const tooltip = document.getElementById('game-tooltip');

        // --- P≈òEP√çN√ÅN√ç POHLED≈Æ ---
        const showScreen = (screen) => {
            document.getElementById('lobby-section').style.display = screen === 'lobby' ? 'flex' : 'none';
            document.getElementById('game-section').style.display = screen === 'game' ? 'flex' : 'none';
        };

        // --- LOBBY LOGIKA ---
        findGameBtn.addEventListener('click', () => {
            const playerName = playerNameInput.value.trim() || 'Anonymn√≠ rod';
            findGameBtn.disabled = true;
            findGameBtn.textContent = 'Hled√°m boji≈°tƒõ...';
            socket.emit('findGame', playerName);
            document.getElementById('name-selection').style.display = 'none';
            document.getElementById('waiting-room').style.display = 'block';
        });

        socket.on('lobbyUpdate', (players) => {
            document.getElementById('playerList').innerHTML = players.map(p => `<li>${p.name}</li>`).join('');
            document.getElementById('waiting-message').textContent = `ƒåek√°n√≠ na dal≈°√≠ hr√°ƒçe (${players.length}/2)...`;
        });

        socket.on('connect', () => { myId = socket.id; showScreen('lobby'); });
        socket.on('disconnect', () => { alert("Spojen√≠ se serverem Avalon bylo p≈ôeru≈°eno."); cancelAnimationFrame(animationFrameId); showScreen('lobby'); });
        socket.on('gameError', (error) => { alert(`Chyba: ${error.message}`); });

        // --- HERN√ç LOGIKA ---
        socket.on('gameStarted', (initialPacket) => {
            console.log("AVALON ZAPOƒåAL:", initialPacket);
            gameState = {
                config: initialPacket.config,
                players: new Map(initialPacket.players.map(p => [p.id, { ...p, resources: {}, pop: {current:0, cap:0}, techs: new Set() }])),
                units: new Map(initialPacket.initialUnits.map(u => [u.id, u])),
                buildings: new Map(initialPacket.initialBuildings.map(b => [b.id, b])),
                board: initialPacket.initialBoard,
                effects: []
            };
            
            showScreen('game');
            resizeCanvas();
            renderFullBoard();
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            gameLoop();
        });

        socket.on('gameStateUpdate', (update) => {
            if (!gameState) return;
            
            update.players?.forEach(pData => Object.assign(gameState.players.get(pData.id) || {}, pData));
            update.units?.forEach(uData => Object.assign(gameState.units.get(uData.id) || {}, uData));
            update.buildings?.forEach(bData => Object.assign(gameState.buildings.get(bData.id) || {}, bData));
            
            update.events?.forEach(event => {
                if (event.type === 'UNIT_CREATED') gameState.units.set(event.data.id, event.data);
                if (event.type === 'BUILDING_CREATED') gameState.buildings.set(event.data.id, event.data);
                if (event.type === 'UNITS_DIED') event.ids.forEach(id => gameState.units.delete(id));
                if (event.type === 'ATTACK_EFFECT') {
                    gameState.effects.push({ ...event, duration: 0.3, maxDuration: 0.3 });
                }
            });

            updateUI();
            if (selectedBuilding || selectedUnits.size > 0) updateSelectionPanel();
        });

        // --- VYKRESLOVAC√ç SMYƒåKA A FUNKCE ---
        function gameLoop() {
            animationFrameId = requestAnimationFrame(gameLoop);
            if (!gameState) return;
            
            entityCtx.clearRect(0, 0, entityCanvas.width, entityCanvas.height);
            entityCtx.save();
            entityCtx.translate(camera.x, camera.y);
            entityCtx.scale(camera.scale, camera.scale);

            renderEntities(entityCtx);
            renderEffects(entityCtx);
            
            entityCtx.restore();
        }

        function renderFullBoard() {
            if (!gameState) return;
            boardCtx.fillStyle = '#111';
            boardCtx.fillRect(0, 0, boardCanvas.width, boardCanvas.height);
            const { TERRAIN } = gameState.config;
            
            for (let y = 0; y < gameState.config.GRID_SIZE; y++) {
                for (let x = 0; x < gameState.config.GRID_SIZE; x++) {
                    const type = gameState.board[y][x];
                    if (TERRAIN[type]) {
                        boardCtx.fillStyle = TERRAIN[type].color;
                        boardCtx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    }
                }
            }
            renderMinimap();
        }
        
        function renderEntities(ctx) {
            // Budovy
            gameState.buildings.forEach(b => {
                const pColor = gameState.players.get(b.ownerId)?.color || 'grey';
                ctx.fillStyle = pColor;
                ctx.fillRect(b.x * CELL_SIZE, b.y * CELL_SIZE, 3 * CELL_SIZE, 3 * CELL_SIZE);
                ctx.strokeStyle = '#000';
                ctx.strokeRect(b.x * CELL_SIZE, b.y * CELL_SIZE, 3 * CELL_SIZE, 3 * CELL_SIZE);
                // Health bar
                if (b.hp < b.maxHp) {
                    drawHealthBar(ctx, b.x * CELL_SIZE, (b.y-0.5) * CELL_SIZE, 3*CELL_SIZE, 4/camera.scale, b.hp / b.maxHp);
                }
                if (selectedBuilding === b.id) {
                     ctx.strokeStyle = 'white';
                     ctx.lineWidth = 3 / camera.scale;
                     ctx.strokeRect(b.x * CELL_SIZE, b.y * CELL_SIZE, 3 * CELL_SIZE, 3 * CELL_SIZE);
                }
            });

            // Jednotky
            gameState.units.forEach(u => {
                const pColor = gameState.players.get(u.ownerId)?.color || 'grey';
                ctx.fillStyle = pColor;
                ctx.beginPath();
                ctx.arc(u.x * CELL_SIZE, u.y * CELL_SIZE, CELL_SIZE * 0.7, 0, 2 * Math.PI);
                ctx.fill();
                if (u.type === "LUCISTNIK") {
                    ctx.fillStyle = "white";
                    ctx.fillRect(u.x * CELL_SIZE - 2/camera.scale, u.y*CELL_SIZE-2/camera.scale, 4/camera.scale, 4/camera.scale);
                }
                if (selectedUnits.has(u.id)) {
                     ctx.strokeStyle = 'white';
                     ctx.lineWidth = 2 / camera.scale;
                     ctx.stroke();
                }
                 if (u.hp < u.maxHp) {
                    drawHealthBar(ctx, u.x * CELL_SIZE - CELL_SIZE, (u.y-1) * CELL_SIZE, 2*CELL_SIZE, 3/camera.scale, u.hp / u.maxHp);
                }
            });
        }
        
        function renderEffects(ctx) {
            ctx.lineWidth = 2 / camera.scale;
            gameState.effects = gameState.effects.filter(e => {
                e.duration -= 1/60; // P≈ôibli≈æn√Ω deltaTime
                if (e.duration <= 0) return false;
                ctx.globalAlpha = e.duration / e.maxDuration;
                if (e.unitType === 'LUCISTNIK') { // St≈ôela
                    ctx.strokeStyle = 'yellow';
                    ctx.beginPath();
                    ctx.moveTo(e.from.x * CELL_SIZE, e.from.y * CELL_SIZE);
                    ctx.lineTo(e.to.x * CELL_SIZE, e.to.y * CELL_SIZE);
                    ctx.stroke();
                } else { // Melee
                    ctx.strokeStyle = 'red';
                    ctx.beginPath();
                    ctx.arc(e.to.x * CELL_SIZE, e.to.y * CELL_SIZE, CELL_SIZE * 0.5, 0, Math.PI * 2);
                    ctx.stroke();
                }
                return true;
            });
            ctx.globalAlpha = 1.0;
        }

        function drawHealthBar(ctx, x, y, width, height, progress) {
            ctx.fillStyle = '#c0392b'; // Red background
            ctx.fillRect(x, y, width, height);
            ctx.fillStyle = '#27ae60'; // Green foreground
            ctx.fillRect(x, y, width * progress, height);
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 0.5 / camera.scale;
            ctx.strokeRect(x,y,width, height);
        }
        
        function renderMinimap() { /* ... bez vƒõt≈°√≠ch zmƒõn, ale p≈ôekresl√≠me ... */ }

        function updateUI() {
            const me = gameState.players.get(myId);
            if(me && me.resources) {
                document.getElementById('gold-display').textContent = Math.floor(me.resources.gold);
                document.getElementById('food-display').textContent = Math.floor(me.resources.food);
                document.getElementById('wood-display').textContent = Math.floor(me.resources.wood);
                document.getElementById('stone-display').textContent = Math.floor(me.resources.stone);
                document.getElementById('science-display').textContent = Math.floor(me.resources.science);
                document.getElementById('pop-display').textContent = `${me.pop.current}/${me.pop.cap}`;
            }
        }
        
        function updateSelectionPanel() {
            const nameEl = document.getElementById('selection-name');
            const detailsEl = document.getElementById('selection-details');
            const actionsEl = document.getElementById('selection-actions');
            detailsEl.innerHTML = '';
            actionsEl.innerHTML = '';

            if (selectedBuilding) {
                const b = gameState.buildings.get(selectedBuilding);
                const b_conf = gameState.config.BUILDINGS[b.type];
                nameEl.textContent = b_conf.name;
                detailsEl.innerHTML = `<p>HP: ${Math.ceil(b.hp)} / ${b.maxHp}</p>`;
                
                if (b_conf.trains) {
                    b_conf.trains.forEach(unitType => {
                        const u_conf = gameState.config.UNITS[unitType];
                        actionsEl.innerHTML += `<button class="action-button" data-action="train" data-unit="${unitType}">${u_conf.name}</button>`;
                    });
                }
                 if(b.trainingQueue?.length > 0) {
                    detailsEl.innerHTML += '<h4>Fronta:</h4>' + b.trainingQueue.map(item => `<div>${gameState.config.UNITS[item.unitType].name} (${Math.floor(item.progress*100)}%)</div>`).join('');
                }

            } else if (selectedUnits.size > 0) {
                 if (selectedUnits.size === 1) {
                    const unit = gameState.units.get(selectedUnits.values().next().value);
                    const u_conf = gameState.config.UNITS[unit.type];
                    nameEl.textContent = u_conf.name;
                    detailsEl.innerHTML = `<p>HP: ${Math.ceil(unit.hp)} / ${unit.maxHp}</p>`;
                    if (unit.can_build) {
                       Object.entries(gameState.config.BUILDINGS).forEach(([key, conf]) => {
                           if(conf.cost.wood) { // Zobrazit jen staviteln√© budovy
                               actionsEl.innerHTML += `<button class="action-button build-button" data-structure="${key}">${conf.name}</button>`;
                           }
                       });
                    }
                 } else {
                     nameEl.textContent = `${selectedUnits.size} jednotek`;
                 }
            } else {
                nameEl.textContent = 'Nic nevybr√°no';
            }
        }

        // --- OVL√ÅD√ÅN√ç A VSTUPY ---
        function getMouseWorldPos(e) {
            const rect = entityCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left - camera.x) / camera.scale;
            const y = (e.clientY - rect.top - camera.y) / camera.scale;
            return { x: x / CELL_SIZE, y: y / CELL_SIZE };
        }

        entityCanvas.addEventListener('mousedown', (e) => {
            const worldPos = getMouseWorldPos(e);
            if (e.button === 0) { // Lev√Ω klik
                if (placingBuildingType) {
                    const builderId = Array.from(selectedUnits).find(id => gameState.units.get(id)?.can_build);
                    if(builderId) {
                        socket.emit('playerAction', { type: 'BUILD_STRUCTURE', payload: { builderId, structureType: placingBuildingType, position: {x: Math.floor(worldPos.x), y: Math.floor(worldPos.y) } } });
                    }
                    placingBuildingType = null;
                    buildGhost.style.display = 'none';
                    entityCanvas.style.cursor = 'default';
                    return;
                }
                
                selectedUnits.clear();
                selectedBuilding = null;
                
                // Zkusit vybrat budovu
                let foundBuilding = null;
                 gameState.buildings.forEach(b => {
                     if (worldPos.x >= b.x && worldPos.x <= b.x + 3 && worldPos.y >= b.y && worldPos.y <= b.y + 3) {
                         foundBuilding = b;
                     }
                 });
                if(foundBuilding) {
                    if (foundBuilding.ownerId === myId) selectedBuilding = foundBuilding.id;
                } else {
                    // Vybrat jednotku
                    let closestUnit = null, minDistSq = 1;
                    gameState.units.forEach(u => {
                        const distSq = (u.x - worldPos.x)**2 + (u.y - worldPos.y)**2;
                        if (distSq < minDistSq) {
                            closestUnit = u;
                            minDistSq = distSq;
                        }
                    });
                    if (closestUnit && closestUnit.ownerId === myId) {
                        selectedUnits.add(closestUnit.id);
                    }
                }
                updateSelectionPanel();
            }
        });

        entityCanvas.addEventListener('contextmenu', (e) => { // Prav√Ω klik
            e.preventDefault();
            if (selectedUnits.size === 0) return;
            const targetPos = getMouseWorldPos(e);
            
            // Zkusit naj√≠t c√≠l √∫toku
            let targetUnit = null;
            gameState.units.forEach(u => {
                if(u.ownerId !== myId) {
                    const distSq = (u.x - targetPos.x)**2 + (u.y - targetPos.y)**2;
                    if(distSq < 1) targetUnit = u;
                }
            });

            if (targetUnit) {
                socket.emit('playerAction', { type: 'ATTACK_TARGET', payload: { unitIds: Array.from(selectedUnits), targetId: targetUnit.id } });
            } else {
                socket.emit('playerAction', { type: 'MOVE_UNITS', payload: { unitIds: Array.from(selectedUnits), target: targetPos } });
            }
        });
        
        // --- Dal≈°√≠ event listenery (pohyb kamery, zoom) z≈Øst√°vaj√≠ podobn√© ---
        // (zkr√°ceno pro p≈ôehlednost)
        let isDragging = false, dragStartPos = { x: 0, y: 0 };
        entityCanvas.addEventListener('mousedown', (e) => { if(e.button === 2 || (e.button === 0 && !e.ctrlKey && !placingBuildingType)) { isDragging = true; dragStartPos = { x: e.clientX - camera.x, y: e.clientY - camera.y }; } });
        entityCanvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                camera.x = e.clientX - dragStartPos.x;
                camera.y = e.clientY - dragStartPos.y;
            }
             if(placingBuildingType) {
                const rect = entityCanvas.getBoundingClientRect();
                buildGhost.style.left = `${e.clientX - rect.left}px`;
                buildGhost.style.top = `${e.clientY - rect.top}px`;
            }
        });
        entityCanvas.addEventListener('mouseup', () => { isDragging = false; });
        entityCanvas.addEventListener('wheel', (e) => { e.preventDefault(); const mousePos = { x: e.clientX - entityCanvas.getBoundingClientRect().left, y: e.clientY - entityCanvas.getBoundingClientRect().top }; const zoom = e.deltaY < 0 ? 1.1 : 1 / 1.1; const newScale = Math.max(0.1, Math.min(camera.scale * zoom, 5.0)); camera.x = mousePos.x - (mousePos.x - camera.x) * (newScale / camera.scale); camera.y = mousePos.y - (mousePos.y - camera.y) * (newScale / camera.scale); camera.scale = newScale; if (placingBuildingType) { buildGhost.style.width = buildGhost.style.height = `${3 * CELL_SIZE * camera.scale}px`; } }, { passive: false });
        
        // Dynamick√© listenery pro akƒçn√≠ panel
        document.getElementById('selection-actions').addEventListener('click', e => {
            if (e.target.matches('.action-button')) {
                const action = e.target.dataset.action;
                if (action === 'train') {
                    socket.emit('playerAction', { type: 'TRAIN_UNIT', payload: { buildingId: selectedBuilding, unitType: e.target.dataset.unit } });
                }
            }
             if (e.target.matches('.build-button')) {
                placingBuildingType = e.target.dataset.structure;
                entityCanvas.style.cursor = 'copy';
                buildGhost.style.display = 'block';
                buildGhost.style.width = buildGhost.style.height = `${3 * CELL_SIZE * camera.scale}px`;
            }
        });

        document.getElementById('tech-tree').addEventListener('click', e => {
             if (e.target.matches('.tech-button')) {
                socket.emit('playerAction', { type: 'RESEARCH_TECH', payload: { techId: e.target.dataset.tech } });
                e.target.classList.add('researched');
                e.target.disabled = true;
             }
        });

        function resizeCanvas() {
            const viewport = document.getElementById('game-viewport');
            [boardCanvas, entityCanvas].forEach(c => { c.width = viewport.clientWidth; c.height = viewport.clientHeight; });
            const minimapPanel = document.querySelector('.minimap-panel');
            minimapCanvas.width = minimapPanel.clientWidth - 30;
            minimapCanvas.height = minimapCanvas.width;
            if(gameState) renderFullBoard();
        }
        window.addEventListener('resize', resizeCanvas);
    </script>
</body>
</html>
<!-- END OF FILE index.html -->