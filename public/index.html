<!-- START OF FILE index.html (Kompletn√≠ fin√°ln√≠ verze) -->

<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <title>AVALON: Zrozen√≠ Imp√©ria</title>
    <link rel="stylesheet" href="styl.css">
</head>
<body>
    <!-- Hlavn√≠ menu -->
    <div id="main-menu-section" class="screen">
        <div class="menu-container">
            <h1>AVALON</h1>
            <h2>Zrozen√≠ Imp√©ria</h2>
            <input type="text" id="playerNameInput" placeholder="Jm√©no tv√©ho rodu..." value="Vojev≈Ødce">
            <button id="soloGameBtn">Hra pro jednoho</button>
            <button id="findGameBtn">Naj√≠t ve≈ôejnou hru</button>
            <button id="createGameBtn">Vytvo≈ôit soukromou hru</button>
            <div class="join-game-form">
                <input type="text" id="joinCodeInput" placeholder="K√≥d hry...">
                <button id="joinGameBtn">P≈ôipojit se</button>
            </div>
        </div>
    </div>
    
    <!-- Lobby / ƒåek√°rna -->
    <div id="lobby-section" class="screen" style="display: none;">
         <div class="lobby-container">
            <h3>ƒåek√° se na velitele...</h3>
            <h4>K√≥d hry: <span id="lobby-game-code"></span></h4>
            <ul id="playerList"></ul>
            <button id="startGameBtn" style="display:none;">Spustit V√°lku</button>
            <p id="waiting-message">ƒåek√°n√≠ na hosta, aby spustil hru...</p>
        </div>
    </div>

    <!-- Sekce HRA -->
    <div id="game-section" style="display: none;">
        <div class="top-bar">
            <div class="resource-panel">
                <div class="resource" title="Zlato">üí∞ <span id="gold-display">0</span></div>
                <div class="resource" title="J√≠dlo">üçñ <span id="food-display">0</span></div>
                <div class="resource" title="D≈ôevo">üå≤ <span id="wood-display">0</span></div>
                <div class="resource" title="K√°men">‚õèÔ∏è <span id="stone-display">0</span></div>
                <div class="resource" title="Vƒõda">üìö <span id="science-display">0</span></div>
            </div>
             <div class="resource-panel">
                <div class="resource" title="Populace / Limit">üßë‚Äçü§ù‚Äçüßë <span id="pop-display">0/0</span></div>
             </div>
        </div>

        <div id="game-container">
            <div id="game-viewport">
                <canvas id="board-canvas"></canvas>
                <canvas id="entity-canvas"></canvas>
                <canvas id="fow-canvas"></canvas>
                 <div id="build-ghost"></div>
            </div>
            <div class="right-panel">
                 <div class="selection-panel">
                    <h3 id="selection-name">Nic nevybr√°no</h3>
                    <div id="selection-details"></div>
                    <div id="selection-actions"></div>
                </div>

                <div class="minimap-panel">
                    <h4>Mapa Vlivu</h4>
                    <canvas id="minimap"></canvas>
                </div>

                <div class="global-actions-panel">
                     <h4>Technologie</h4>
                     <div id="tech-tree">
                        <button class="action-button tech-button" data-tech="vylepsene_zemedelstvi" title="Vylep≈°en√© zemƒõdƒõlstv√≠ (50 Vƒõda)">Farma+ (50)</button>
                        <button class="action-button tech-button" data-tech="kovarstvi" title="Kov√°≈ôstv√≠ (100 Vƒõda)">Meƒç+ (100)</button>
                        <button class="action-button tech-button" data-tech="opevneni" title="Opevnƒõn√≠ (75 Vƒõda)">Hradby+ (75)</button>
                     </div>
                </div>
            </div>
        </div>
        <div id="game-tooltip"></div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();

        // --- STAV A KONSTANTY KLIENTA ---
        let gameState = null;
        let myId = null;
        let animationFrameId = null;
        let camera = { x: 0, y: 0, scale: 0.5 };
        const CELL_SIZE = 12;
        let selectedUnits = new Set();
        let selectedBuilding = null;
        let placingBuildingType = null;
        const FOW_STATE = { HIDDEN: 0, EXPLORED: 1, VISIBLE: 2 };
        let visibilityMap = null;

        // --- KANVAS A KONTEXTY ---
        const boardCanvas = document.getElementById('board-canvas');
        const boardCtx = boardCanvas.getContext('2d', { alpha: false });
        const entityCanvas = document.getElementById('entity-canvas');
        const entityCtx = entityCanvas.getContext('2d');
        const fowCanvas = document.getElementById('fow-canvas');
        const fowCtx = fowCanvas.getContext('2d');
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');
        
        // --- V√ùBƒöR ELEMENT≈Æ ---
        const playerNameInput = document.getElementById('playerNameInput');
        const buildGhost = document.getElementById('build-ghost');
        
        // --- P≈òEP√çN√ÅN√ç POHLED≈Æ ---
        const showScreen = (screenName) => {
            document.querySelectorAll('.screen').forEach(s => s.style.display = 'none');
            document.getElementById(`${screenName}-section`).style.display = 'flex';
        };

        // --- LOBBY LOGIKA ---
        const setPlayerName = () => socket.emit('setPlayerName', playerNameInput.value.trim() || 'Anonym');

        document.getElementById('soloGameBtn').addEventListener('click', () => {
            setPlayerName();
            socket.emit('createLobby', { isPrivate: true });
            socket.once('lobbyCreated', ({ gameCode }) => {
                socket.emit('startGame', gameCode);
            });
        });
        document.getElementById('findGameBtn').addEventListener('click', () => {
            setPlayerName();
            socket.emit('findPublicLobby');
        });
        document.getElementById('createGameBtn').addEventListener('click', () => {
            setPlayerName();
            socket.emit('createLobby', { isPrivate: true });
        });
        document.getElementById('joinGameBtn').addEventListener('click', () => {
            const code = document.getElementById('joinCodeInput').value.trim().toUpperCase();
            if (code) {
                setPlayerName();
                socket.emit('joinLobby', code);
            }
        });
        document.getElementById('startGameBtn').addEventListener('click', () => {
            if (gameState && gameState.gameCode) {
                socket.emit('startGame', gameState.gameCode);
            }
        });

        socket.on('connect', () => { myId = socket.id; showScreen('main-menu'); });
        socket.on('disconnect', () => { alert("Spojen√≠ se serverem Avalon bylo p≈ôeru≈°eno."); cancelAnimationFrame(animationFrameId); location.reload(); });
        socket.on('gameError', (error) => { alert(`Chyba: ${error.message}`); });

        socket.on('lobbyCreated', ({ gameCode }) => {
            gameState = { gameCode };
            document.getElementById('lobby-game-code').textContent = gameCode;
            showScreen('lobby');
        });
        socket.on('lobbyFound', (gameCode) => {
            setPlayerName();
            socket.emit('joinLobby', gameCode);
            gameState = { gameCode };
            document.getElementById('lobby-game-code').textContent = gameCode;
            showScreen('lobby');
        });

        socket.on('lobbyUpdate', ({ players, hostId }) => {
            const playerList = document.getElementById('playerList');
            playerList.innerHTML = players.map(p => `<li class="${p.id === hostId ? 'host' : ''}">${p.name} ${p.id === hostId ? '(Host)' : ''}</li>`).join('');
            
            const startBtn = document.getElementById('startGameBtn');
            const waitingMsg = document.getElementById('waiting-message');
            if(myId === hostId) {
                startBtn.style.display = 'block';
                waitingMsg.textContent = `Hra je p≈ôipravena pro ${players.length} hr√°ƒçe.`;
            } else {
                startBtn.style.display = 'none';
                waitingMsg.textContent = 'ƒåek√°n√≠ na hosta, aby spustil hru...';
            }
        });

        // --- HERN√ç LOGIKA ---
        socket.on('gameStarted', (initialPacket) => {
            console.log("AVALON ZAPOƒåAL:", initialPacket);
            gameState = {
                ...initialPacket,
                players: new Map(initialPacket.players.map(p => [p.id, { ...p, resources: {}, pop: {current:0, cap:0}, techs: new Set() }])),
                units: new Map(),
                buildings: new Map(),
                effects: []
            };
            
            visibilityMap = new Uint8Array(gameState.config.GRID_SIZE * gameState.config.GRID_SIZE).fill(FOW_STATE.HIDDEN);
            
            showScreen('game');
            resizeCanvas();
            renderFullBoard();
            renderFOW();
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            gameLoop();
        });

        socket.on('gameStateUpdate', (update) => {
            if (!gameState) return;
            
            update.players?.forEach(pData => {
                const player = gameState.players.get(pData.id);
                if (player) Object.assign(player, pData);
            });

            let fowChanged = false;
            if (update.visibilityChanges?.length > 0) {
                fowChanged = true;
                update.visibilityChanges.forEach(cell => {
                    visibilityMap[cell.y * gameState.config.GRID_SIZE + cell.x] = cell.state;
                });
            }

            const visibleUnits = new Map(update.units.map(u => [u.id, u]));
            const visibleBuildings = new Map(update.buildings.map(b => [b.id, b]));
            gameState.units = visibleUnits;
            gameState.buildings = visibleBuildings;

            update.events?.forEach(event => {
                if (event.type === 'UNITS_DIED') {
                    event.ids.forEach(id => {
                        if (selectedUnits.has(id)) selectedUnits.delete(id);
                    });
                }
                if (event.type === 'ATTACK_EFFECT') {
                    gameState.effects.push({ ...event, duration: 0.3, maxDuration: 0.3 });
                }
            });

            updateUI();
            if (selectedBuilding || selectedUnits.size > 0) updateSelectionPanel();
            if (fowChanged) {
                renderFOW();
                renderMinimap();
            }
        });
        
        socket.on('gameOver', ({reason}) => {
             alert(`Konec hry! ${reason}`);
             cancelAnimationFrame(animationFrameId);
             location.reload();
        });

        // --- VYKRESLOVAC√ç SMYƒåKA A FUNKCE ---
        function gameLoop() {
            animationFrameId = requestAnimationFrame(gameLoop);
            if (!gameState) return;
            
            entityCtx.clearRect(0, 0, entityCanvas.width, entityCanvas.height);
            entityCtx.save();
            entityCtx.translate(camera.x, camera.y);
            entityCtx.scale(camera.scale, camera.scale);

            renderEntities(entityCtx);
            renderEffects(entityCtx);
            
            entityCtx.restore();
        }

        function renderFullBoard() {
            if (!gameState) return;
            boardCanvas.width = gameState.config.GRID_SIZE * CELL_SIZE;
            boardCanvas.height = gameState.config.GRID_SIZE * CELL_SIZE;

            boardCtx.fillStyle = '#111';
            boardCtx.fillRect(0, 0, boardCanvas.width, boardCanvas.height);
            const { TERRAIN } = gameState.config;
            
            for (let y = 0; y < gameState.config.GRID_SIZE; y++) {
                for (let x = 0; x < gameState.config.GRID_SIZE; x++) {
                    const type = gameState.board[y][x];
                    if (TERRAIN[type]) {
                        boardCtx.fillStyle = TERRAIN[type].color;
                        boardCtx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    }
                }
            }
            renderMinimap();
        }

        function renderFOW() {
            if (!gameState || !visibilityMap) return;
            fowCtx.clearRect(0, 0, fowCanvas.width, fowCanvas.height);
            
            const startX = Math.floor(-camera.x / camera.scale);
            const startY = Math.floor(-camera.y / camera.scale);
            const viewWidth = fowCanvas.width / camera.scale;
            const viewHeight = fowCanvas.height / camera.scale;

            fowCtx.save();
            fowCtx.translate(camera.x, camera.y);
            fowCtx.scale(camera.scale, camera.scale);

            // This is an off-screen canvas for the full FoW map
            const fowMapCanvas = document.createElement('canvas');
            fowMapCanvas.width = gameState.config.GRID_SIZE * CELL_SIZE;
            fowMapCanvas.height = gameState.config.GRID_SIZE * CELL_SIZE;
            const fowMapCtx = fowMapCanvas.getContext('2d');

            const exploredColor = "rgba(0, 0, 0, 0.5)";
            const hiddenColor = "black";
            const gridSize = gameState.config.GRID_SIZE;

            for (let i = 0; i < visibilityMap.length; i++) {
                const state = visibilityMap[i];
                if (state !== FOW_STATE.VISIBLE) {
                    const x = (i % gridSize) * CELL_SIZE;
                    const y = Math.floor(i / gridSize) * CELL_SIZE;
                    fowMapCtx.fillStyle = state === FOW_STATE.EXPLORED ? exploredColor : hiddenColor;
                    fowMapCtx.fillRect(x, y, CELL_SIZE, CELL_SIZE);
                }
            }
            fowCtx.drawImage(fowMapCanvas, 0, 0);
            fowCtx.restore();
        }
        
        function renderEntities(ctx) {
            gameState.buildings.forEach(b => {
                const pColor = gameState.players.get(b.ownerId)?.color || 'grey';
                ctx.fillStyle = pColor;
                ctx.fillRect(b.x * CELL_SIZE, b.y * CELL_SIZE, 3 * CELL_SIZE, 3 * CELL_SIZE);
                ctx.strokeStyle = '#000';
                ctx.strokeRect(b.x * CELL_SIZE, b.y * CELL_SIZE, 3 * CELL_SIZE, 3 * CELL_SIZE);
                if (b.hp < b.maxHp) {
                    drawHealthBar(ctx, b.x * CELL_SIZE, (b.y-0.5) * CELL_SIZE, 3*CELL_SIZE, 4/camera.scale, b.hp / b.maxHp);
                }
                if (selectedBuilding === b.id) {
                     ctx.strokeStyle = 'white';
                     ctx.lineWidth = 3 / camera.scale;
                     ctx.strokeRect(b.x * CELL_SIZE, b.y * CELL_SIZE, 3 * CELL_SIZE, 3 * CELL_SIZE);
                }
            });

            gameState.units.forEach(u => {
                const pColor = gameState.players.get(u.ownerId)?.color || 'grey';
                ctx.fillStyle = pColor;
                ctx.beginPath();
                ctx.arc(u.x * CELL_SIZE, u.y * CELL_SIZE, CELL_SIZE * 0.7, 0, 2 * Math.PI);
                ctx.fill();
                if (u.type === "LUCISTNIK") {
                    ctx.fillStyle = "white";
                    ctx.fillRect(u.x * CELL_SIZE - 2/camera.scale, u.y*CELL_SIZE-2/camera.scale, 4/camera.scale, 4/camera.scale);
                }
                if (selectedUnits.has(u.id)) {
                     ctx.strokeStyle = 'white';
                     ctx.lineWidth = 2 / camera.scale;
                     ctx.stroke();
                }
                 if (u.hp < u.maxHp) {
                    drawHealthBar(ctx, u.x * CELL_SIZE - CELL_SIZE, (u.y-1) * CELL_SIZE, 2*CELL_SIZE, 3/camera.scale, u.hp / u.maxHp);
                }
            });
        }
        
        function renderEffects(ctx) {
            ctx.lineWidth = 2 / camera.scale;
            gameState.effects = gameState.effects.filter(e => {
                e.duration -= 1/60;
                if (e.duration <= 0) return false;
                ctx.globalAlpha = e.duration / e.maxDuration;
                if (e.unitType === 'LUCISTNIK') {
                    ctx.strokeStyle = 'yellow';
                    ctx.beginPath();
                    ctx.moveTo(e.from.x * CELL_SIZE, e.from.y * CELL_SIZE);
                    ctx.lineTo(e.to.x * CELL_SIZE, e.to.y * CELL_SIZE);
                    ctx.stroke();
                } else {
                    ctx.strokeStyle = 'red';
                    ctx.beginPath();
                    ctx.arc(e.to.x * CELL_SIZE, e.to.y * CELL_SIZE, CELL_SIZE * 0.5, 0, Math.PI * 2);
                    ctx.stroke();
                }
                return true;
            });
            ctx.globalAlpha = 1.0;
        }

        function drawHealthBar(ctx, x, y, width, height, progress) {
            ctx.fillStyle = '#c0392b';
            ctx.fillRect(x, y, width, height);
            ctx.fillStyle = '#27ae60';
            ctx.fillRect(x, y, width * progress, height);
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 0.5 / camera.scale;
            ctx.strokeRect(x,y,width, height);
        }
        
        function renderMinimap() {
            if (!gameState) return;
            const size = gameState.config.GRID_SIZE;
            const pixelSize = minimapCanvas.width / size;
            minimapCtx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);
            
            for(let y = 0; y < size; y++) {
                for(let x = 0; x < size; x++) {
                    const state = visibilityMap[y * size + x];
                    if (state === FOW_STATE.VISIBLE || state === FOW_STATE.EXPLORED) {
                        const type = gameState.board[y][x];
                        minimapCtx.fillStyle = gameState.config.TERRAIN[type]?.color || 'black';
                        if (state === FOW_STATE.EXPLORED) {
                            minimapCtx.globalAlpha = 0.5;
                        }
                        minimapCtx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
                        minimapCtx.globalAlpha = 1.0;
                    }
                }
            }

            gameState.players.forEach(p => {
                minimapCtx.fillStyle = p.color;
                gameState.units.forEach(u => {
                    if (u.ownerId === p.id) {
                         minimapCtx.fillRect(u.x * pixelSize, u.y * pixelSize, pixelSize, pixelSize);
                    }
                });
                 gameState.buildings.forEach(b => {
                    if (b.ownerId === p.id) {
                         minimapCtx.fillRect(b.x * pixelSize, b.y * pixelSize, pixelSize * 2, pixelSize * 2);
                    }
                });
            });
        }

        function updateUI() {
            const me = gameState.players.get(myId);
            if(me && me.resources) {
                document.getElementById('gold-display').textContent = Math.floor(me.resources.gold);
                document.getElementById('food-display').textContent = Math.floor(me.resources.food);
                document.getElementById('wood-display').textContent = Math.floor(me.resources.wood);
                document.getElementById('stone-display').textContent = Math.floor(me.resources.stone);
                document.getElementById('science-display').textContent = Math.floor(me.resources.science);
                document.getElementById('pop-display').textContent = `${me.pop.current}/${me.pop.cap}`;
            }
        }
        
        function updateSelectionPanel() {
            const nameEl = document.getElementById('selection-name');
            const detailsEl = document.getElementById('selection-details');
            const actionsEl = document.getElementById('selection-actions');
            detailsEl.innerHTML = '';
            actionsEl.innerHTML = '';

            if (selectedBuilding && gameState.buildings.has(selectedBuilding)) {
                const b = gameState.buildings.get(selectedBuilding);
                const b_conf = gameState.config.BUILDINGS[b.type];
                nameEl.textContent = b_conf.name;
                detailsEl.innerHTML = `<p>HP: ${Math.ceil(b.hp)} / ${b.maxHp}</p>`;
                
                if (b_conf.trains) {
                    b_conf.trains.forEach(unitType => {
                        const u_conf = gameState.config.UNITS[unitType];
                        actionsEl.innerHTML += `<button class="action-button" data-action="train" data-unit="${unitType}">${u_conf.name}</button>`;
                    });
                }
                 if(b.trainingQueue?.length > 0) {
                    detailsEl.innerHTML += '<h4>Fronta:</h4>' + b.trainingQueue.map(item => `<div>${gameState.config.UNITS[item.unitType].name} (${Math.floor(item.progress*100)}%)</div>`).join('');
                }

            } else if (selectedUnits.size > 0) {
                 if (selectedUnits.size === 1) {
                    const unitId = selectedUnits.values().next().value;
                    if(gameState.units.has(unitId)) {
                        const unit = gameState.units.get(unitId);
                        const u_conf = gameState.config.UNITS[unit.type];
                        nameEl.textContent = u_conf.name;
                        detailsEl.innerHTML = `<p>HP: ${Math.ceil(unit.hp)} / ${unit.maxHp}</p>`;
                        if (unit.can_build) {
                           Object.entries(gameState.config.BUILDINGS).forEach(([key, conf]) => {
                               if(conf.cost.wood || conf.cost.gold) {
                                   actionsEl.innerHTML += `<button class="action-button build-button" data-structure="${key}">${conf.name}</button>`;
                               }
                           });
                        }
                    } else { selectedUnits.clear(); updateSelectionPanel(); }
                 } else {
                     nameEl.textContent = `${selectedUnits.size} jednotek`;
                 }
            } else {
                nameEl.textContent = 'Nic nevybr√°no';
            }
        }

        // --- OVL√ÅD√ÅN√ç A VSTUPY ---
        function getMouseWorldPos(e) {
            const rect = entityCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / camera.scale - (camera.x / camera.scale);
            const y = (e.clientY - rect.top) / camera.scale - (camera.y / camera.scale);
            return { x: x / CELL_SIZE, y: y / CELL_SIZE };
        }

        entityCanvas.addEventListener('mousedown', (e) => {
            const worldPos = getMouseWorldPos(e);
            if (e.button === 0) {
                if (placingBuildingType) {
                    const builderId = Array.from(selectedUnits).find(id => gameState.units.get(id)?.can_build);
                    if(builderId) {
                        socket.emit('playerAction', { type: 'BUILD_STRUCTURE', payload: { builderId, structureType: placingBuildingType, position: {x: Math.floor(worldPos.x), y: Math.floor(worldPos.y) } } });
                    }
                    placingBuildingType = null;
                    buildGhost.style.display = 'none';
                    entityCanvas.style.cursor = 'default';
                    return;
                }
                
                selectedUnits.clear();
                selectedBuilding = null;
                
                let foundBuilding = null;
                gameState.buildings.forEach(b => {
                    if (worldPos.x >= b.x && worldPos.x <= b.x + 3 && worldPos.y >= b.y && worldPos.y <= b.y + 3) {
                        foundBuilding = b;
                    }
                });
                if(foundBuilding) {
                    if (foundBuilding.ownerId === myId) selectedBuilding = foundBuilding.id;
                } else {
                    let closestUnit = null, minDistSq = 1;
                    gameState.units.forEach(u => {
                        const distSq = (u.x - worldPos.x)**2 + (u.y - worldPos.y)**2;
                        if (distSq < minDistSq) {
                            closestUnit = u;
                            minDistSq = distSq;
                        }
                    });
                    if (closestUnit && closestUnit.ownerId === myId) {
                        selectedUnits.add(closestUnit.id);
                    }
                }
                updateSelectionPanel();
            }
        });

        entityCanvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            if (placingBuildingType) {
                placingBuildingType = null;
                buildGhost.style.display = 'none';
                entityCanvas.style.cursor = 'default';
                return;
            }

            if (selectedUnits.size === 0) return;
            const targetPos = getMouseWorldPos(e);
            
            let targetUnit = null;
            gameState.units.forEach(u => {
                if(u.ownerId !== myId) {
                    const distSq = (u.x - targetPos.x)**2 + (u.y - targetPos.y)**2;
                    if(distSq < 1) targetUnit = u;
                }
            });

            if (targetUnit) {
                socket.emit('playerAction', { type: 'ATTACK_TARGET', payload: { unitIds: Array.from(selectedUnits), targetId: targetUnit.id } });
            } else {
                socket.emit('playerAction', { type: 'MOVE_UNITS', payload: { unitIds: Array.from(selectedUnits), target: targetPos } });
            }
        });
        
        let isDragging = false, dragStartPos = { x: 0, y: 0 };
        entityCanvas.addEventListener('mousedown', (e) => { if(e.button === 1 || (e.button === 0 && e.altKey)) { isDragging = true; dragStartPos = { x: e.clientX - camera.x, y: e.clientY - camera.y }; } });
        entityCanvas.addEventListener('mousemove', (e) => {
            const worldPos = getMouseWorldPos(e);
            if (isDragging) {
                camera.x = e.clientX - dragStartPos.x;
                camera.y = e.clientY - dragStartPos.y;
                renderFOW();
            }
             if(placingBuildingType) {
                const rect = entityCanvas.getBoundingClientRect();
                buildGhost.style.left = `${Math.floor(worldPos.x) * CELL_SIZE * camera.scale + camera.x}px`;
                buildGhost.style.top = `${Math.floor(worldPos.y) * CELL_SIZE * camera.scale + camera.y}px`;
            }
        });
        entityCanvas.addEventListener('mouseup', () => { isDragging = false; });
        entityCanvas.addEventListener('mouseleave', () => { isDragging = false; });
        entityCanvas.addEventListener('wheel', (e) => { e.preventDefault(); const mousePos = { x: e.clientX - entityCanvas.getBoundingClientRect().left, y: e.clientY - entityCanvas.getBoundingClientRect().top }; const zoom = e.deltaY < 0 ? 1.1 : 1 / 1.1; const newScale = Math.max(0.1, Math.min(camera.scale * zoom, 3.0)); const worldX = (mousePos.x - camera.x) / camera.scale; const worldY = (mousePos.y - camera.y) / camera.scale; camera.x = mousePos.x - worldX * newScale; camera.y = mousePos.y - worldY * newScale; camera.scale = newScale; if (placingBuildingType) { buildGhost.style.width = buildGhost.style.height = `${3 * CELL_SIZE * camera.scale}px`; } renderFOW(); }, { passive: false });
        
        document.getElementById('selection-actions').addEventListener('click', e => {
            if (e.target.matches('.action-button')) {
                const action = e.target.dataset.action;
                if (action === 'train') {
                    socket.emit('playerAction', { type: 'TRAIN_UNIT', payload: { buildingId: selectedBuilding, unitType: e.target.dataset.unit } });
                }
            }
             if (e.target.matches('.build-button')) {
                placingBuildingType = e.target.dataset.structure;
                entityCanvas.style.cursor = 'copy';
                buildGhost.style.display = 'block';
                buildGhost.style.width = buildGhost.style.height = `${3 * CELL_SIZE * camera.scale}px`;
            }
        });

        document.getElementById('tech-tree').addEventListener('click', e => {
             if (e.target.matches('.tech-button')) {
                socket.emit('playerAction', { type: 'RESEARCH_TECH', payload: { techId: e.target.dataset.tech } });
                e.target.classList.add('researched');
                e.target.disabled = true;
             }
        });

        function resizeCanvas() {
            const viewport = document.getElementById('game-viewport');
            [entityCanvas, fowCanvas].forEach(c => { c.width = viewport.clientWidth; c.height = viewport.clientHeight; });
            const minimapPanel = document.querySelector('.minimap-panel');
            minimapCanvas.width = minimapPanel.clientWidth - 30;
            minimapCanvas.height = minimapCanvas.width;
            if(gameState) {
                renderFullBoard();
                renderFOW();
            }
        }
        window.addEventListener('resize', resizeCanvas);
    </script>
</body>
</html>
<!-- END OF FILE index.html (Kompletn√≠ fin√°ln√≠ verze) -->