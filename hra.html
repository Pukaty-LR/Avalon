<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixelov√° ≈ò√≠≈°e - Fin√°ln√≠ Verze</title>
    <style>
        :root {
            --grid-size: 400; 
            --cell-size: 10px; --gap-size: 1px;
            --color-player-land: #3d9440; --color-player-base: #5aab5d; --color-player-border: #81c784;
            --color-mine: #795548; --color-village: #03A9F4; --color-hidden: #282828; --color-expanding: #336e35;
            --color-ui-bg: #1a1a1a; --color-ui-border: #888; --color-text: #eee;
            --color-gold: #ffd700; --color-crystal: #4dd0e1; --color-forest: #1b5e20;
            --color-road: #a1887f;
        }
        body { font-family: 'Segoe UI', sans-serif; background-color: #000; color: var(--color-text); display: flex; align-items: flex-start; justify-content: center; padding: 20px; gap: 30px; image-rendering: pixelated; overflow: hidden; }
        .game-column, .info-column { display: flex; flex-direction: column; align-items: center; z-index: 10; }
        h1 { color: var(--color-player-land); font-size: 1.5em; }
        
        #game-viewport { width: 80vw; height: 95vh; border: 2px solid var(--color-ui-border); overflow: hidden; position: relative; background-color: #111; }
        #game-grid { position: absolute; display: grid; grid-template-columns: repeat(var(--grid-size), var(--cell-size)); grid-template-rows: repeat(var(--grid-size), var(--cell-size)); gap: var(--gap-size); background-color: #444; cursor: grab; transform-origin: 0 0; }
        #game-grid:active { cursor: grabbing; }

        #border-container, #icon-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .structure-border { position: absolute; box-sizing: border-box; border: 2px solid var(--color-player-border); z-index: 4; }
        .structure-icon { position: absolute; display: flex; align-items: center; justify-content: center; z-index: 5; color: white; }

        .stats-panel { width: 280px; padding: 15px; background-color: var(--color-ui-bg); border: 2px solid var(--color-ui-border); margin-bottom: 20px; }
        .stats-panel h2 { margin: 0 0 15px 0; text-align: center; border-bottom: 1px solid #444; padding-bottom: 10px; }
        .stat { display: flex; justify-content: space-between; margin-bottom: 10px; font-size: 1.1em; }
        .stat-value { font-weight: bold; }
        #gold-display { color: var(--color-gold); }
        #crystals-display { color: var(--color-crystal); }
        .unit-buy-button { width: 100%; padding: 8px; margin-top: 10px; cursor: pointer; border: none; border-radius: 5px; font-size: 1em; color: white; background-color: #3f51b5; }
        .unit-buy-button:hover { background-color: #303f9f; }
        .stat-slider { margin-top: 20px; padding-top: 15px; border-top: 1px solid #444; }
        .stat-slider label { display: block; margin-bottom: 8px; }
        #expedition-slider { width: 100%; }
        #expedition-slider-value { display: block; text-align: center; margin-top: 5px; }
        .cell { width: var(--cell-size); height: var(--cell-size); position: relative; user-select: none; }
        .cell.hidden { background-color: var(--color-hidden); }
        .cell.owned-land { background-color: var(--color-player-land); }
        .cell.owned-base, .cell.owned-village, .cell.owned-mine, .cell.owned-crystal_mine, .cell.owned-ancient_library, .cell.owned-trading_post, .cell.owned-barracks, .cell.owned-watchtower { background-color: var(--color-player-base); }
        .cell.visible-mine { background-color: var(--color-mine); }
        .cell.visible-village { background-color: var(--color-village); }
        .cell.visible-crystal_mine { background-color: var(--color-crystal); }
        .cell.visible-ancient_library { background-color: #673ab7; }
        .cell.visible-trading_post { background-color: #ff9800; }
        .cell.expanding { background-color: var(--color-expanding); }
        .cell.terrain-forest { background-color: var(--color-forest); }
        .cell.terrain-road { background-color: var(--color-road); }
        #action-panel, .log-container { width: 280px; background-color: var(--color-ui-bg); border: 2px solid var(--color-ui-border); padding: 15px; }
        #action-panel { min-height: 150px; text-align: center; }
        #action-panel h3 { margin-top: 0; }
        #action-panel p { margin: 10px 0 15px 0; line-height: 1.5; }
        #action-panel button { width: 100%; padding: 10px; margin-top: 10px; cursor: pointer; border: 1px solid var(--color-ui-border); border-radius: 5px; font-size: 1em; color: var(--color-text); background-color: #4a4a4a; }
        #action-panel button:hover:not(:disabled) { background-color: #6a6a6a; }
        #action-panel button:disabled { background-color: #333; color: #777; cursor: not-allowed; }
        .log-container { height: 180px; overflow-y: auto; margin-top: 20px; font-size: 0.9em; }
        .context-menu { position: fixed; z-index: 100; background-color: var(--color-ui-bg); border: 1px solid var(--color-ui-border); padding: 5px; border-radius: 5px; display: flex; flex-direction: column; gap: 4px; }
        .context-menu button { background-color: var(--color-player-land); color: white; border: none; padding: 8px 12px; cursor: pointer; width: 100%; font-size: 0.9em; text-align: left;}
        .context-menu button:hover { background-color: var(--color-player-base); }
    </style>
</head>
<body>
    <div class="info-column">
        <div class="stats-panel">
            <h2>STAV ≈ò√ç≈†E</h2>
            <div class="stat"><span>üí∞ Zlato:</span> <span id="gold-display" class="stat-value">0</span></div>
            <div class="stat"><span>üíé Krystaly:</span> <span id="crystals-display" class="stat-value">0</span></div>
            <div class="stat"><span>üìà P≈ô√≠jem/s:</span> <span id="income-display" class="stat-value">0</span></div>
            <div class="stat"><span>‚öîÔ∏è Jednotky:</span> <span id="units-display" class="stat-value">0</span></div>
            <div class="stat"><span>üõ∞Ô∏è Expedice:</span> <span id="expeditions-display" class="stat-value">0</span></div>
            <button class="unit-buy-button" id="buy-unit-button">Koupit jednotku (50üí∞)</button>
            <div class="stat-slider">
                <label for="expedition-slider">Velikost expedice:</label>
                <input type="range" id="expedition-slider" min="1" max="100" value="5">
                <span id="expedition-slider-value">5% (0)</span>
            </div>
        </div>
        <div id="action-panel"><h3>Akƒçn√≠ Panel</h3><p>Klikni na budovu pro info.</p></div>
        <div class="log-container" id="log-container"></div>
    </div>
    <div class="game-column">
        <h1>Pixelov√° ≈ò√≠≈°e</h1>
        <div id="game-viewport">
            <div id="game-grid">
                <div id="border-container"></div>
                <div id="icon-container"></div>
            </div>
        </div>
        <button id="reset-button" style="margin-top:20px; padding:10px 20px;">Restart</button>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const GRID_SIZE = 400, INITIAL_GOLD = 500, INITIAL_UNITS = 20, INITIAL_CRYSTALS = 0;
        const UNIT_COST = 50, BASE_INCOME = 5, NUM_STRUCTURES = 1000, ATTRITION_RATE = 20;
        const EXPANSION_TICK_RATE = 100, PRODUCTION_TICK_RATE = 15000, TERRAIN_DENSITY = 0.1;

        const viewportEl = document.getElementById('game-viewport'), gridEl = document.getElementById('game-grid'),
              goldEl = document.getElementById('gold-display'), crystalsEl = document.getElementById('crystals-display'),
              incomeEl = document.getElementById('income-display'), unitsEl = document.getElementById('units-display'),
              expeditionsEl = document.getElementById('expeditions-display'), buyUnitBtn = document.getElementById('buy-unit-button'),
              slider = document.getElementById('expedition-slider'), sliderValueEl = document.getElementById('expedition-slider-value'),
              actionPanelEl = document.getElementById('action-panel'), logEl = document.getElementById('log-container'),
              resetBtn = document.getElementById('reset-button');
        
        let gold, units, income, crystals, gameBoard, structures, selectedStructureId = null;
        let gameLoopInterval = null, incomeInterval = null, productionInterval = null;
        let activeExpeditions = [], expeditionCounter = 0;
        
        let isDragging = false, didDrag = false;
        let startPos = { x: 0, y: 0 }, gridPos = { x: 0, y: 0 };
        let scale = 1.0;
        const MIN_SCALE = 0.2, MAX_SCALE = 2.5;

        const BUILDINGS = {
            barracks: { name: "Kas√°rny", cost: { gold: 150, crystals: 5 }, size: 3, upkeep: { gold: 2 } },
            watchtower: { name: "Str√°≈æn√≠ vƒõ≈æ", cost: { gold: 100, crystals: 0 }, size: 2, effect: { attrition_reduction: 0.5, radius: 10 } }
        };

        function initGame() {
            [gameLoopInterval, incomeInterval, productionInterval].forEach(clearInterval);
            gridEl.innerHTML = `<div id="border-container"></div><div id="icon-container"></div>`;
            logEl.innerHTML = ''; removeContextMenu();

            gold = INITIAL_GOLD; units = INITIAL_UNITS; income = BASE_INCOME;
            crystals = INITIAL_CRYSTALS; gameBoard = [];
            structures = new Map(); selectedStructureId = null;
            activeExpeditions = []; expeditionCounter = 0;

            for (let y = 0; y < GRID_SIZE; y++) {
                const row = []; for (let x = 0; x < GRID_SIZE; x++) {
                    const cellData = { x, y, state: 'hidden', structureId: null, terrain: 'none' };
                    if (Math.random() < TERRAIN_DENSITY) cellData.terrain = Math.random() < 0.6 ? 'forest' : 'road';
                    const cellEl = document.createElement('div');
                    cellEl.className = 'cell hidden'; cellEl.dataset.x = x; cellEl.dataset.y = y;
                    cellData.element = cellEl;
                    gridEl.insertBefore(cellEl, gridEl.firstChild);
                    row.push(cellData);
                }
                gameBoard.push(row);
            }

            const baseSize = 6, baseX = Math.floor(GRID_SIZE / 2 - baseSize / 2), baseY = Math.floor(GRID_SIZE / 2 - baseSize / 2);
            createStructure('owned_base', baseX, baseY, baseSize, baseSize, { name: 'Hlavn√≠ stan' });
            
            for (let i = 0; i < NUM_STRUCTURES; i++) {
                const rand = Math.random();
                if (rand < 0.35) placeRandomStructure('mine', 2, { name: 'D≈Øl', income: 5, cost: 100 });
                else if (rand < 0.70) placeRandomStructure('village', 3, { name: 'Vesnice', unit_bonus: 5, cost: 75 });
                else if (rand < 0.85) placeRandomStructure('crystal_mine', 2, { name: 'Krystalov√Ω d≈Øl', income: 1, cost: 300 });
                else if (rand < 0.95) placeRandomStructure('ancient_library', 4, { name: 'Prastar√° knihovna', reveal_radius: 15, cost: 250 });
                else placeRandomStructure('trading_post', 3, { name: 'Tr≈æi≈°tƒõ', cost: 150 });
            }
            
            const viewportRect = viewportEl.getBoundingClientRect();
            scale = 0.5;
            gridPos.x = viewportRect.width / 2 - (baseX * (10+1) * scale);
            gridPos.y = viewportRect.height / 2 - (baseY * (10+1) * scale);
            updateGridTransform();

            if(!gridEl.dataset.listenersAttached) {
                viewportEl.addEventListener('mousedown', onMouseDown); viewportEl.addEventListener('mousemove', onMouseMove);
                viewportEl.addEventListener('mouseup', onMouseUp); viewportEl.addEventListener('mouseleave', onMouseUp);
                viewportEl.addEventListener('wheel', onWheel, { passive: false });
                slider.addEventListener('input', updateSliderLabel);
                document.addEventListener('click', (e) => { if (!e.target.closest('.context-menu')) removeContextMenu(); });
                resetBtn.addEventListener('click', initGame);
                buyUnitBtn.addEventListener('click', () => { if (gold >= UNIT_COST) { gold -= UNIT_COST; units++; updateUI(); } });
                gridEl.addEventListener('click', onGridClick); gridEl.addEventListener('contextmenu', handleRightClick);
                gridEl.dataset.listenersAttached = 'true';
            }
            
            incomeInterval = setInterval(incomeLoop, 1000);
            productionInterval = setInterval(productionLoop, PRODUCTION_TICK_RATE);
            gameLoopInterval = setInterval(expansionLoop, EXPANSION_TICK_RATE);
            
            updateUI();
            logMessage('V√≠tej! Pohybuj mapou lev√Ωm tlaƒç√≠tkem a zoomuj koleƒçkem.');
        }

        function onMouseDown(e) { if (e.button !== 0) return; isDragging = true; didDrag = false; gridEl.style.cursor = 'grabbing'; startPos.x = e.clientX - gridPos.x; startPos.y = e.clientY - gridPos.y; }
        function onMouseMove(e) { if (!isDragging) return; if(!didDrag && Math.hypot(e.clientX - (startPos.x + gridPos.x), e.clientY - (startPos.y + gridPos.y)) > 5) { didDrag = true; removeContextMenu(); } if(didDrag) { gridPos.x = e.clientX - startPos.x; gridPos.y = e.clientY - startPos.y; updateGridTransform(); } }
        function onMouseUp(e) { isDragging = false; gridEl.style.cursor = 'grab'; }
        function onWheel(e) { e.preventDefault(); const rect = viewportEl.getBoundingClientRect(); const mouseX = e.clientX - rect.left; const mouseY = e.clientY - rect.top; const oldScale = scale; scale -= e.deltaY * 0.001 * scale; scale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, scale)); gridPos.x = mouseX - (mouseX - gridPos.x) * (scale / oldScale); gridPos.y = mouseY - (mouseY - gridPos.y) * (scale / oldScale); updateGridTransform(); }
        function updateGridTransform() { gridEl.style.transform = `translate(${gridPos.x}px, ${gridPos.y}px) scale(${scale})`; }
        function onGridClick(e){ if(didDrag) return; const cellEl = e.target.closest('.cell'); if(cellEl) { const x = parseInt(cellEl.dataset.x); const y = parseInt(cellEl.dataset.y); handleCellClick(gameBoard[y][x]); } }
        
        function incomeLoop() { gold += income; structures.forEach(s => { if(s.upkeep) gold -= s.upkeep.gold; }); updateUI(); }
        function productionLoop() { let newUnits = 0; let newCrystals = 0; structures.forEach(s => { if(s.type === 'owned_barracks') newUnits++; if(s.type === 'owned_crystal_mine') newCrystals += s.data.income; }); units += newUnits; crystals += newCrystals; updateUI(); }
        
        function expansionLoop() {
            if (activeExpeditions.length === 0) return;
            const expeditionsToRemove = new Set();
            const candidateCells = findExpansionCandidates();

            if (candidateCells.size === 0) {
                activeExpeditions.forEach(exp => expeditionsToRemove.add(exp.id));
                if(expeditionsToRemove.size > 0) logMessage(`V≈°echny expedice konƒç√≠, nen√≠ kam expandovat.`);
            } else {
                for (const expedition of activeExpeditions) {
                    const speed = 1000 / (expedition.unitsLeft + 5);
                    if (Date.now() - expedition.lastStep < speed) continue;
                    expedition.lastStep = Date.now();
                    
                    let bestCandidate = null; let minDistance = Infinity;
                    for(const cell of candidateCells) {
                        if(cell.state === 'hidden') {
                            const distance = Math.hypot(cell.x - expedition.targetX, cell.y - expedition.targetY);
                            if (distance < minDistance) { minDistance = distance; bestCandidate = cell; }
                        }
                    }

                    if (bestCandidate) {
                        bestCandidate.state = 'expanding';
                        updateCellVisual(bestCandidate);

                        setTimeout(() => {
                            if (bestCandidate.state !== 'expanding') return;
                            bestCandidate.state = 'owned';
                            if (bestCandidate.structureId !== null) {
                                handleDiscovery(bestCandidate, expedition);
                                expeditionsToRemove.add(expedition.id);
                            } else { updateCellVisual(bestCandidate); }
                            let attritionModifier = 1.0;
                            if (bestCandidate.terrain === 'forest') attritionModifier = 2.0;
                            if (bestCandidate.terrain === 'road') attritionModifier = 0.0;
                            structures.forEach(s => { if (s.type === 'owned_watchtower' && Math.hypot(bestCandidate.x - s.x, bestCandidate.y - s.y) <= s.data.effect.radius) { attritionModifier *= s.data.effect.attrition_reduction; } });
                            expedition.attritionCounter -= (1 / (attritionModifier || 0.1));
                            if (expedition.attritionCounter <= 0) { expedition.unitsLeft--; expedition.attritionCounter = ATTRITION_RATE; if (expedition.unitsLeft <= 0) { logMessage(`Expedice #${expedition.id} se vyƒçerpala.`, 'lose'); expeditionsToRemove.add(expedition.id); } }
                        }, 50);
                    }
                }
            }
            if (expeditionsToRemove.size > 0) { activeExpeditions = activeExpeditions.filter(exp => !expeditionsToRemove.has(exp.id)); updateUI(); }
        }
        
        function handleRightClick(e) {
            e.preventDefault();
            removeContextMenu();
            const cellEl = e.target.closest('.cell');
            if (!cellEl || didDrag) return;
            const gridX = parseInt(cellEl.dataset.x);
            const gridY = parseInt(cellEl.dataset.y);
            const cell = gameBoard[gridY][gridX];
            if (cell.state === 'hidden') {
                showExpeditionMenu(gridX, gridY, e);
            } else if (cell.state === 'owned' && cell.structureId === null) {
                showBuildMenu(gridX, gridY, e);
            }
        }

        function showExpeditionMenu(gridX, gridY, event) {
            const menu = createContextMenu(event.clientX, event.clientY);
            const btn = document.createElement('button');
            btn.textContent = 'üõ∞Ô∏è Vyslat expedici';
            btn.onclick = () => {
                launchExpedition(gridX, gridY);
                removeContextMenu();
            };
            menu.appendChild(btn);
        }

        function showBuildMenu(gridX, gridY, event) {
            const menu = createContextMenu(event.clientX, event.clientY);
            for (const type in BUILDINGS) {
                const building = BUILDINGS[type];
                const btn = document.createElement('button');
                btn.innerHTML = `${building.name} (${building.cost.gold}üí∞ ${building.cost.crystals}üíé)`;
                const canAfford = gold >= building.cost.gold && crystals >= building.cost.crystals;
                if (!canAfford) btn.disabled = true;
                btn.onclick = () => {
                    buildStructure(type, gridX, gridY);
                    removeContextMenu();
                };
                menu.appendChild(btn);
            }
        }
        
        function launchExpedition(targetX, targetY) {
            console.log(`Pos√≠l√°m expedici na c√≠l -> X: ${targetX}, Y: ${targetY}`);
            const unitsToSend = Math.max(1, Math.ceil(units * (slider.value / 100)));
            if (units < unitsToSend) { logMessage(`Nedostatek jednotek!`, 'lose'); return; }
            units -= unitsToSend;
            expeditionCounter++;
            const newExpedition = { id: expeditionCounter, targetX, targetY, unitsLeft: unitsToSend, attritionCounter: ATTRITION_RATE, lastStep: Date.now() };
            activeExpeditions.push(newExpedition);
            logMessage(`Vysl√°na expedice #${newExpedition.id} s ${unitsToSend} jednotkami.`);
            updateUI();
        }

        function buildStructure(type, x, y) { const building = BUILDINGS[type]; if (gold < building.cost.gold || crystals < building.cost.crystals) { logMessage(`Nedostatek surovin na ${building.name}!`, 'lose'); return; } if (!isAreaClear(x, y, building.size, building.size)) { logMessage(`Zde nelze stavƒõt, m√≠sto je obsazen√©.`, 'lose'); return; } gold -= building.cost.gold; crystals -= building.cost.crystals; createStructure(`owned_${type}`, x, y, building.size, building.size, building); logMessage(`Postaveno: ${building.name}.`, 'win'); updateUI(); }
        function handleDiscovery(discoveredCell, expedition) { logMessage(`Expedice #${expedition.id} objevila ${structures.get(discoveredCell.structureId).data.name} a konƒç√≠.`); revealStructure(structures.get(discoveredCell.structureId)); }
        window.captureStructure = (id) => { const struct = structures.get(id); if (gold < struct.data.cost) { logMessage(`Nem√°≈° dostatek zlata na obsazen√≠!`, 'lose'); return; } gold -= struct.data.cost; const oldType = struct.type; if (!oldType.startsWith('owned_')) { struct.type = `owned_${oldType}`; } if (oldType === 'mine') income += struct.data.income; else if (oldType === 'village') units += struct.data.unit_bonus; else if (oldType === 'ancient_library') revealArea(struct.x + Math.floor(struct.w/2), struct.y + Math.floor(struct.h/2), struct.data.reveal_radius); for (let i = struct.y; i < struct.y + struct.h; i++) { for (let j = struct.x; j < struct.x + struct.w; j++) { if (gameBoard[i]?.[j]) { gameBoard[i][j].state = 'owned'; } } } logMessage(`Z√≠skal jsi kontrolu nad ${struct.data.name}!`, 'win'); updateStructureVisuals(struct); updateUI(); updateActionPanel(); };

        function updateUI() { goldEl.textContent = Math.floor(gold); crystalsEl.textContent = Math.floor(crystals); incomeEl.textContent = `${income}üí∞/s`; unitsEl.textContent = units; expeditionsEl.textContent = activeExpeditions.length; buyUnitBtn.disabled = gold < UNIT_COST; updateSliderLabel(); }
        function updateSliderLabel() { const p = slider.value; const u = Math.max(1, Math.ceil(units * (p/100))); sliderValueEl.textContent = `${p}% (${u} ‚öîÔ∏è)`; }
        function updateCellVisual(cell) { cell.element.className = 'cell'; if (cell.state !== 'hidden' && cell.terrain !== 'none') cell.element.classList.add(`terrain-${cell.terrain}`); let stateClass = cell.state; if (cell.state === 'owned') { if(cell.structureId) { stateClass = structures.get(cell.structureId).type; } else { stateClass = 'owned-land'; } } else if (cell.state === 'visible') { if(cell.structureId) { stateClass = structures.get(cell.structureId).type; } else { stateClass = 'hidden'; } } cell.element.classList.add(stateClass); }
        
        function updateStructureVisuals(struct) {
            for (let i = struct.y; i < struct.y + struct.h; i++) { for (let j = struct.x; j < struct.x + struct.w; j++) { if(gameBoard[i]?.[j]) updateCellVisual(gameBoard[i][j]); } }
            const borderContainer = document.getElementById('border-container'); const iconContainer = document.getElementById('icon-container');
            let borderEl = document.getElementById(`border-${struct.id}`); let iconEl = document.getElementById(`icon-${struct.id}`);
            
            // --- EXPERIMENT√ÅLN√ç OPRAVA ZAƒå√çN√Å ZDE ---
            let drawX = struct.x;
            let drawY = struct.y;
            // Podm√≠nka, abychom neovlivnili hlavn√≠ z√°kladnu
            if (struct.type !== 'owned_base' && struct.type !== 'base') {
                // Toto je implementace "inverze" jako zrcadlen√≠ p≈ôes st≈ôed mapy.
                // Vypoƒç√≠t√°me "opaƒçnou" sou≈ôadnici a odeƒçteme velikost pro spr√°vn√© zarovn√°n√≠.
                drawX = GRID_SIZE - struct.x - struct.w;
                drawY = GRID_SIZE - struct.y - struct.h;
            }
            // --- EXPERIMENT√ÅLN√ç OPRAVA KONƒå√ç ZDE ---

            const isOwned = struct.type.startsWith('owned_');
            if (isOwned) { 
                if(!borderEl) { borderEl = document.createElement('div'); borderEl.id = `border-${struct.id}`; borderEl.className = 'structure-border'; borderContainer.appendChild(borderEl); } 
                const cellSize = 10, gapSize = 1; 
                borderEl.style.left = `${drawX * (cellSize + gapSize)}px`; borderEl.style.top = `${drawY * (cellSize + gapSize)}px`; 
                borderEl.style.width = `${struct.w * (cellSize + gapSize) - gapSize}px`; borderEl.style.height = `${struct.h * (cellSize + gapSize) - gapSize}px`; 
            } else if (borderEl) { borderEl.remove(); }

            const isVisible = gameBoard[struct.y][struct.x].state !== 'hidden';
            if (isVisible) { 
                if(!iconEl) { iconEl = document.createElement('div'); iconEl.id = `icon-${struct.id}`; iconEl.className = 'structure-icon'; iconContainer.appendChild(iconEl); } 
                const cellSize = 10, gapSize = 1; 
                iconEl.style.left = `${drawX * (cellSize + gapSize)}px`; iconEl.style.top = `${drawY * (cellSize + gapSize)}px`; 
                iconEl.style.width = `${struct.w * (cellSize + gapSize) - gapSize}px`; iconEl.style.height = `${struct.h * (cellSize + gapSize) - gapSize}px`; 
                const iconMap = { base: 'üè°', village: 'üèòÔ∏è', mine: '‚õèÔ∏è', crystal_mine: 'üíé', ancient_library: 'üìö', trading_post: '‚öñÔ∏è', barracks: '‚öîÔ∏è', watchtower: 'üëÅÔ∏è' }; 
                let iconChar = ''; 
                for(const key in iconMap) { if(struct.type.includes(key)) iconChar = iconMap[key]; } 
                iconEl.textContent = iconChar; 
                iconEl.style.fontSize = `${struct.w * (cellSize + gapSize) * 0.6}px`; 
            } else if (iconEl) { iconEl.remove(); }
        }

        function createStructure(type, x, y, w, h, data) { const id = structures.size + Date.now(); const newStructure = { id, type, x, y, w, h, data, upkeep: data.upkeep || null }; structures.set(id, newStructure); for (let i = y; i < y + h; i++) { for (let j = x; j < x + w; j++) { if (gameBoard[i]?.[j]) gameBoard[i][j].structureId = id; } } if (type.startsWith('owned_')) { for (let i = y; i < y + h; i++) { for (let j = x; j < x + w; j++) { if(gameBoard[i]?.[j]) gameBoard[i][j].state = 'owned'; } } } updateStructureVisuals(newStructure); }
        function revealArea(cx, cy, radius) { for (let y = 0; y < GRID_SIZE; y++) { for (let x = 0; x < GRID_SIZE; x++) { if (Math.hypot(x - cx, y - cy) <= radius) { const cell = gameBoard[y][x]; if (cell.state === 'hidden') { cell.state = 'owned'; if (cell.structureId) revealStructure(structures.get(cell.structureId)); else updateCellVisual(cell); } } } } }
        function handleCellClick(cellData) { removeContextMenu(); if (cellData.structureId !== null && cellData.state !== 'hidden') { selectedStructureId = cellData.structureId; updateActionPanel(); } else { selectedStructureId = null; actionPanelEl.innerHTML = `<h3>Akƒçn√≠ Panel</h3><p>Klikni na budovu/zemƒõ pro akce.</p>`; } }
        function updateActionPanel() { if (selectedStructureId === null) { actionPanelEl.innerHTML = `<h3>Akƒçn√≠ Panel</h3><p>Klikni na budovu pro info.</p>`; return; } const struct = structures.get(selectedStructureId); let html = `<h3>${struct.data.name}</h3>`; let type = struct.type.replace('owned_', ''); const isOwned = struct.type.startsWith('owned_'); let btn = ''; if(!isOwned) btn = `<button onclick="captureStructure(${struct.id})" ${gold < struct.data.cost ? 'disabled' : ''}>Obsadit</button>`; switch(type) { case 'base': html += `<p>Centrum tv√© ≈ô√≠≈°e.</p>`; break; case 'village': html += isOwned ? `<p>Tato vesnice ti poskytla ${struct.data.unit_bonus} jednotek.</p>` : `<p>Obsazen√≠m za ${struct.data.cost}üí∞ z√≠sk√°≈° ${struct.data.unit_bonus} jednotek.</p>${btn}`; break; case 'mine': html += isOwned ? `<p>Produkuje +${struct.data.income}üí∞/s.</p>` : `<p>Obsazen√≠m za ${struct.data.cost}üí∞ z√≠sk√°≈° +${struct.data.income}üí∞/s.</p>${btn}`; break; case 'crystal_mine': html += isOwned ? `<p>Produkuje +${struct.data.income}üíé/15s.</p>` : `<p>Obsazen√≠m za ${struct.data.cost}üí∞ z√≠sk√°≈° +${struct.data.income}üíé/15s.</p>${btn}`; break; case 'ancient_library': html += isOwned ? `<p>Tato knihovna ti odhalila ƒç√°st mapy.</p>` : `<p>Obsazen√≠m za ${struct.data.cost}üí∞ odhal√≠≈° okol√≠.</p>${btn}`; break; case 'trading_post': html += `<p>Vymƒõ≈à 5 jednotek za 200üí∞.</p><button onclick="if(units>=5){units-=5; gold+=200; updateUI(); logMessage('Vymƒõnƒõno 5‚öîÔ∏è za 200üí∞.','win');}">Smƒõnit</button>`; break; case 'barracks': html += `<p>Produkuje 1‚öîÔ∏è/15s. √ödr≈æba: ${struct.data.upkeep.gold}üí∞/s.</p>`; break; case 'watchtower': html += `<p>Sni≈æuje opot≈ôeben√≠ expedic v dosahu ${struct.data.effect.radius} pol√≠.</p>`; break; default: html += `<p>Nezn√°m√° struktura.</p>`; break; } actionPanelEl.innerHTML = html; }
        function logMessage(message, type = 'info') { const msgEl = document.createElement('div'); let icon = '‚ÑπÔ∏è'; if (type === 'win') icon = '‚úÖ'; if (type === 'lose') icon = '‚ùå'; msgEl.textContent = `> ${icon} ${message}`; logEl.prepend(msgEl); }
        function removeContextMenu() { document.querySelector('.context-menu')?.remove(); }
        function createContextMenu(x, y) { removeContextMenu(); const menu = document.createElement('div'); menu.className = 'context-menu'; menu.style.left = `${x}px`; menu.style.top = `${y}px`; document.body.appendChild(menu); return menu; }
        function isAreaClear(x, y, w, h) { for (let i = y; i < y + h; i++) { for (let j = x; j < x + w; j++) { if (i >= GRID_SIZE || j >= GRID_SIZE || gameBoard[i]?.[j]?.structureId !== null) return false; } } return true; }
        function placeRandomStructure(type, size, data) { let placed = false, attempts=0; while (!placed && attempts < 500) { const x = Math.floor(Math.random() * (GRID_SIZE - size)); const y = Math.floor(Math.random() * (GRID_SIZE - size)); if (isAreaClear(x, y, size, size)) { createStructure(type, x, y, size, size, data); placed = true; } attempts++; } }
        function revealStructure(struct) { for (let i = struct.y; i < struct.y + struct.h; i++) { for (let j = struct.x; j < struct.x + struct.w; j++) { if(gameBoard[i]?.[j]?.state === 'hidden') { gameBoard[i][j].state = 'visible'; updateCellVisual(gameBoard[i][j]); } } } updateStructureVisuals(struct); }
        function findExpansionCandidates() { const candidates = new Set(); for(let y=0; y<GRID_SIZE; y++){ for(let x=0; x<GRID_SIZE; x++){ if(gameBoard[y][x].state === 'owned'){ getNeighbors(x,y).forEach(n => { if(n.state === 'hidden') candidates.add(n); }); } } } return candidates; }
        function findClosestFrontierCell(frontier, targetX, targetY) { return frontier.reduce((p, c) => (Math.hypot(c.x-targetX, c.y-targetY) < Math.hypot(p.x-targetX, p.y-targetY) ? c : p)); }
        function getNeighbors(x,y) { const n = []; for(let dy = -1; dy <= 1; dy++) { for(let dx = -1; dx <= 1; dx++) { if((dx === 0 && dy === 0) || !gameBoard[y+dy]?.[x+dx]) continue; n.push(gameBoard[y+dy][x+dx]); } } return n; }
        
        initGame();
    });
    </script>
</body>
</html>